//Andrew Hoyle

#include <cstdlib>
#include <iostream>
#include <fstream>

#include "mineSweeperGlobals.h"
#include "board.h"
#include "mineSweeperFunctions.h"
#include "testingInfo.h"

/* The following is code generated by Andrew Hoyle with research help
 * from colleagues Yiming Zhao and Nick Young.  This minesweeper program
 * and the 3 algorithms that play the game were developed in partial
 * fulfillment of the undergrad algorithms class at UC Denver in spring
 * 2012.  The 3 algorithms play identical games, and their successes 
 * are counted.  See README for more detailed information. */

int main(int argc, char** argv) 
{
    //change the name of the output file to be created here!
    //app mode prevents clobbering
    std::ofstream outfile("minesweeper_results", std::ofstream::out | std::ofstream::app);
    if(!outfile)
    {
        std::cout<<"Could not open output file.\n";
        return EXIT_FAILURE;
    }
    
    //change these max mine values for the number of tests
    // you want to want to run for calculating heuristics
    for(int maxMines=1; maxMines<=51; maxMines+=5)
    {
        //values for board and testingInfo
        //how many times you want a game with maxMines to be
        // generated randomly and played by the 3 algos.
        int TRIALS=10;
        int MINES=maxMines;     //#of mines randomly scattered on board
        int BOARDROW=18;        //dimensions of board, (take edges into account)
        int BOARDCOL=32;

        //create the struct that holds the info
        // for the outfile
        testingInfo ti1, ti2, ti3, ti4;

        ti1.minesOnBoard=MINES;
        ti1.tilesOnBoard=BOARDROW*BOARDCOL;

        ti2.minesOnBoard=MINES;
        ti2.tilesOnBoard=BOARDROW*BOARDCOL;

        ti3.minesOnBoard=MINES;
        ti3.tilesOnBoard=BOARDROW*BOARDCOL;

        ti4.minesOnBoard=MINES;
        ti4.tilesOnBoard=BOARDROW*BOARDCOL;

        //pointers to each of the algorithms to pass to
        // playTheGame()
        Algo calcsRisks = &oneAtATimeThenCalcRisksTile;
        Algo backToDumb = &oneAtATimeThenGuessTile;
        Algo dumbDumb = &dumbRandomSelectTile;
        Algo smartest = &theSmartOne;

        for(int i=0; i<TRIALS; ++i)
        {
            //create board to pass to algorithms
            board theBoard1(MINES, BOARDROW, BOARDCOL);

            //make copies of the board for each algorithm
            board theBoard2(theBoard1);
            board theBoard3(theBoard1);
            board theBoard4(theBoard1);

            std::cout << "-------------------- Game#: " << i+1 << " -----------------------\n";

            //play the game!
            std::cout << "\nLevel 1 dumb-dumb: ----------------\n";
            playTheGame(theBoard3, dumbDumb, ti3);
            std::cout << "\nLevel 2 calcRisks: ----------------\n";
            playTheGame(theBoard1, calcsRisks, ti1);
            std::cout << "\nLevel 2 backToGuess: --------------\n";
            playTheGame(theBoard2, backToDumb, ti2);
            std::cout << "\nLevel 3 smartest?: ----------------\n";
            playTheGame(theBoard4, smartest, ti4);
        }

        outfile << "---- trials:\t" << TRIALS <<
                "\trows:\t" << BOARDROW << 
                "\tcols:\t" << BOARDCOL <<
                "\tmines:\t" << MINES << " ----"<< std::endl << std::endl;

        outfile << "calcsRisks: " << ti1.numberOfWins << std::endl;
        outfile << "backToDumb: " << ti2.numberOfWins << std::endl;
        outfile << "dumbDumb: " << ti3.numberOfWins << std::endl;
        outfile << "\"smartest\": " << ti4.numberOfWins << std::endl;
        outfile << std::endl;
    
    }
    return EXIT_SUCCESS;
}

